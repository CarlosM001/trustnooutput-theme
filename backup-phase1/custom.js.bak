/* ==========================================================================
   TRUST.NO.OUTPUT â€” custom.js (PRODUCTION READY)
   Motion: Page Fade, Reveal & Glitch Effects
   Version: 1.0.0
   ========================================================================== */

(function () {
  "use strict";

  /* Configuration */
  const CONFIG = {
    fadeIn: {
      duration: 600,
      delay: 60,
    },
    reveal: {
      threshold: 0.2,
      rootMargin: "0px",
    },
    parallax: {
      speed: 0.15,
      mouseSpeed: 0.02,
    },
    glitch: {
      minDelay: 300,
      maxDelay: 700,
    },
  };

  /* 1) Page Fade-In Effect */
  const initPageFade = () => {
    document.body.style.opacity = 0;
    document.body.style.transition = `opacity ${CONFIG.fadeIn.duration}ms ease`;

    requestAnimationFrame(() => {
      setTimeout(() => {
        document.body.style.opacity = 1;
      }, CONFIG.fadeIn.delay);
    });

    // Handle browser back/forward navigation
    window.addEventListener("pageshow", (e) => {
      if (e.persisted) {
        document.body.style.opacity = 0;
        setTimeout(() => {
          document.body.style.opacity = 1;
        }, 50);
      }
    });
  };

  /* 2) Reveal & Parallax Observer */
  const initScrollEffects = () => {
    const elements = document.querySelectorAll(".reveal, [data-parallax]");
    if (!elements.length) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    if (prefersReducedMotion) {
      elements.forEach((el) => {
        el.classList.add("is-visible");
        if (el.hasAttribute("data-parallax")) {
          el.style.transform = "none";
        }
      });
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("is-visible");
            if (entry.target.hasAttribute("data-parallax")) {
              entry.target.classList.add("in-view");
            }
            observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: CONFIG.reveal.threshold,
        rootMargin: CONFIG.reveal.rootMargin,
      }
    );

    elements.forEach((el) => observer.observe(el));
  };

  /* 3) Glitch Effect Initialization */
  const initGlitchEffects = () => {
    const glitchElements = document.querySelectorAll(
      ".tno-glitch-strong, .tno-glitch-soft, .glitch"
    );

    glitchElements.forEach((el) => {
      // Set data-text attribute if not present
      if (!el.hasAttribute("data-text")) {
        el.setAttribute("data-text", el.textContent);
      }

      // Trigger initial glitch
      el.style.animation = "none";
      setTimeout(
        () => {
          el.style.animation = "";
        },
        CONFIG.glitch.minDelay +
          Math.random() * (CONFIG.glitch.maxDelay - CONFIG.glitch.minDelay)
      );
    });
  };

  /* 4) Scroll Parallax */
  const initScrollParallax = () => {
    const parallaxElements = document.querySelectorAll(
      "[data-parallax].in-view"
    );
    if (!parallaxElements.length) return;

    let ticking = false;

    const updateParallax = () => {
      const scrollY = window.scrollY || window.pageYOffset;

      parallaxElements.forEach((el) => {
        const rect = el.getBoundingClientRect();
        const speed = parseFloat(el.dataset.parallax) || CONFIG.parallax.speed;
        const yPos = -(scrollY * speed);

        el.style.transform = `translate3d(0, ${yPos}px, 0)`;
      });

      ticking = false;
    };

    const requestTick = () => {
      if (!ticking) {
        window.requestAnimationFrame(updateParallax);
        ticking = true;
      }
    };

    window.addEventListener("scroll", requestTick, { passive: true });
  };

  /* 5) Mouse Parallax */
  const initMouseParallax = () => {
    const mouseElements = document.querySelectorAll("[data-mouse-parallax]");
    if (!mouseElements.length) return;

    let mouseX = 0;
    let mouseY = 0;
    let windowWidth = window.innerWidth;
    let windowHeight = window.innerHeight;
    let rafId = null;

    const handleMouseMove = (e) => {
      mouseX = (e.clientX / windowWidth - 0.5) * 2;
      mouseY = (e.clientY / windowHeight - 0.5) * 2;

      if (!rafId) {
        rafId = requestAnimationFrame(updateElements);
      }
    };

    const updateElements = () => {
      mouseElements.forEach((el) => {
        const speed =
          parseFloat(el.dataset.mouseParallax) || CONFIG.parallax.mouseSpeed;
        const x = mouseX * speed * 100;
        const y = mouseY * speed * 100;

        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      });

      rafId = null;
    };

    const handleResize = () => {
      windowWidth = window.innerWidth;
      windowHeight = window.innerHeight;
    };

    window.addEventListener("mousemove", handleMouseMove, { passive: true });
    window.addEventListener("resize", handleResize, { passive: true });
  };

  /* 6) Initialize Everything */
  const init = () => {
    // Immediate initializations
    initPageFade();

    // DOM-dependent initializations
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        initScrollEffects();
        initGlitchEffects();
        initScrollParallax();
        initMouseParallax();
      });
    } else {
      // DOM already loaded
      initScrollEffects();
      initGlitchEffects();
      initScrollParallax();
      initMouseParallax();
    }
  };

  // Start initialization
  init();

  // Export for debugging (only in development)
  if (window.Shopify && window.Shopify.designMode) {
    window.TNO = {
      CONFIG,
      reinit: init,
    };
  }
})();
